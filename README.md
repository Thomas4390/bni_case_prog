# Cas de programmation | BNI

*disclaimer* : Au cours de ce projet et de l'implémentation des différentes stratégies, j'ai fait de mon mieux afin de minimiser les erreurs de backtestings courantes dans le temps qui m'étais imparti. La principale erreur que l'on peut commetre en backtesting est d'utiliser des données futures pour prédire le passé. Avec du temps supplémentaire, j'aurais pu tester plus rigoureusement chacune des fonctions avant de passer à la suite du projet et ainsi être certain d'éviter ce genre d'erreur.  

# Description de la structure du projet : 

- **converted_data** (dossier) : Contient les données de départ converties au format .parquet afin de rendre l'ouverture et le téléchargement des données plus rapide. 
- **data** (dossier) : Contient les données de départ auxquelles la 2ème ligne a manuellement été retirée afin de rendre la lecture et la conversion en .parquet plus facile. Ces données n'ont pas été mise en ligne sur GitHub à cause de leur taille trop volumineuse. 
- **documentation** (dossier) : Contient la documentation utilisée pour le cas. 
- **figures** (dossier) : Contient les graphiques utilisés dans le projet. Note : La majeure partie des figures se trouvent sous la forme d'un fichier html dans le dossier **results_data**. 
- **filtered_data** (dossier) : Contient les données après filtration par le filtre de liquidité. Les extensions sont en .parquet. 
- **results_data** (dossier) : Contient les résultats les plus importants du projet. On y retrouve les métriques de performance (avec de nombreux graphiques) sous la forme d'une page hmtl pour les 3 stratégies testées (base_strategy, new_strategy et other_strategy). Les fichiers html sont censés pouvoir être ouverts à partir de l'éditeur de code ou avec un utilitaire de fichier. On y retrouve aussi la répartition des poids annuels concernant les secteurs GICS, les poids de rééquilibrage annuels ainsi que les "daily drifted weights" pour chacune des stratégies. 
- **backtesting.py** (fichier) : Script qui contient le calcul des "daily drifted weights" ainsi que la comparaison des performances des différentes stratégies par rapport au benchmark. Les outputs sont ensuite sauvergardés dans le dossier results_data. 
- **base_strategy.py** (fichier) : Ce script exécute la stratégie de la volatilité inverse de base, en prenant en compte des contraintes sur les poids de manière individuel et des contraintes sectorielles. Le détail de la stratégie se trouve en haut du script. Le script contient aussi des fonctions qui permettent de vérifier que les critères ont bien été respectés, comme par exemple le fait que les poids doivent sommer à 1, ou encore que les contraintes d'inégalités sont respectées. Si les contraintes ne sont pas respectées, un message d'erreur apparaît dans la console (l'allocation est quand même obtenue). Pour certains paramètres initiaux, il peut arriver que les contraintes ne soient légèrement pas respectées. La performance de cette stratégie est comparé au benchmark dans le dossier **results_data** avec le fichier html : `base_strategy_metrics.html`. 
- **new_strategy.py** (fichier) : Ce script exécute la stratégie de volatilité inverse avec skewness. Le détail de la stratégie se trouve en haut du script. Cette stratégie d'investissement est basée sur l'inverse de la volatilité et la skewness négative des actifs du portefeuille. Elle vise à attribuer des poids aux actifs en tenant compte de ces deux mesures. Après une longue période d'optimisation, j'ai pu observer que les contraintes sectorielles n'avaient pas été respectées pour le secteur `#NA NA` que j'ai renommé en `Not Attributed` dans le script **preprocessing**. La performance de cette stratégie est comparé au benchmark dans le dossier **results_data** avec le fichier html : `other_strategy_metrics.html`. 
